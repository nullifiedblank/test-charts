<section class="panel-content">

  <!-- Panel ribbon -->
  <ul class="ribbon">

    <li id="ribbon-filters">
      <button
        class="button is-ribbon is-filter"
        hx-get="templates/partials/dropdowns/charts-filters.html"
        hx-trigger="load"
        hx-swap="outerHTML"
      >Filters</button>
    </li>

    <li>
      <p>Data is in UTC timezone</p>
    </li>
  </ul>

  <!-- Chart -->
  <style>
    /* Ensure filters dropdown is above the chart */
    .drop {
      z-index: 2000 !important;
    }
  </style>
  <section class="chart-wrapper">
    <div class="chart is-events">
      <canvas id="chart-events"></canvas>
    </div>
  </section>
</section>
<script>
  window.initChartEvents = function() {
    const ctx = document.getElementById('chart-events');
    if (!ctx) return;

    // Check if chart instance already exists
    const existingChart = Chart.getChart(ctx);
    if (existingChart) {
      existingChart.destroy();
    }

    // Helper to convert hex to rgba
    const hexToRgba = (hex, alpha) => {
        if (!hex || !hex.startsWith('#')) return hex;
        let r = 0, g = 0, b = 0;
        // Handle shorthand #abc
        if (hex.length === 4) {
            r = parseInt(hex[1] + hex[1], 16);
            g = parseInt(hex[2] + hex[2], 16);
            b = parseInt(hex[3] + hex[3], 16);
        } else if (hex.length === 7) {
            r = parseInt(hex.slice(1, 3), 16);
            g = parseInt(hex.slice(3, 5), 16);
            b = parseInt(hex.slice(5, 7), 16);
        }
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const createGradient = (ctx, chartArea, color) => {
      // Defensive check: if chartArea is undefined (e.g. not rendered yet), return solid color
      if (!chartArea) return hexToRgba(color, 0.5);

      const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
      gradient.addColorStop(0, hexToRgba(color, 0.5));
      gradient.addColorStop(1, hexToRgba(color, 0));
      return gradient;
    };

    const labels = ['January', 'February', 'March', 'April', 'May', 'June', 'July'];

    const data = {
      labels: labels,
      datasets: [
        {
          label: 'Email processed',
          _filterName: 'filter_processed',
          borderColor: '#abb5c4',
          backgroundColor: '#abb5c4',
          data: [65, 59, 80, 81, 56, 55, 40],
        },
        {
          label: 'Soft bounced',
          _filterName: 'filter_soft',
          borderColor: '#e2b466',
          backgroundColor: '#e2b466',
          data: [28, 48, 40, 19, 86, 27, 90],
        },
        {
          label: 'Hard bounced',
          _filterName: 'filter_hard',
          borderColor: '#b3812e',
          backgroundColor: '#b3812e',
          data: [18, 28, 20, 19, 36, 17, 50],
        },
        {
          label: 'Rejected',
          _filterName: 'filter_rejected',
          borderColor: '#a64a39',
          backgroundColor: '#a64a39',
          data: [5, 10, 5, 2, 8, 3, 10],
        },
        {
          label: 'Marked as spam',
          _filterName: 'filter_spam',
          borderColor: '#ce715f',
          backgroundColor: '#ce715f',
          data: [2, 5, 2, 1, 4, 2, 5],
        },
        {
          label: 'Delivered to recipient',
          _filterName: 'filter_delivered',
          borderColor: '#12becb',
          backgroundColor: '#12becb',
          data: [60, 50, 70, 75, 50, 50, 35],
        },
        {
          label: 'Recipient unsubscribed',
          _filterName: 'filter_unsubscribed',
          borderColor: '#01a2ee',
          backgroundColor: '#01a2ee',
          data: [10, 20, 15, 25, 20, 15, 10],
        },
        {
          label: 'Recipient resubscribed',
          _filterName: 'filter_resubscribed',
          borderColor: '#a9c1c1',
          backgroundColor: '#a9c1c1',
          data: [1, 2, 1, 3, 2, 1, 1],
        },
        {
          label: 'Opened by recipient',
          _filterName: 'filter_opened',
          borderColor: '#00ba7a',
          backgroundColor: '#00ba7a',
          data: [50, 40, 60, 65, 40, 40, 25],
        },
        {
          label: 'Link clicked by recipient',
          _filterName: 'filter_clicked',
          borderColor: '#b57ad4',
          backgroundColor: '#b57ad4',
          data: [30, 25, 35, 40, 25, 25, 15],
        }
      ]
    };

    // Apply visibility based on current DOM state of checkboxes
    // Also save original colors
    data.datasets.forEach(ds => {
      ds._originalBorderColor = ds.borderColor;
      ds._originalBackgroundColor = ds.backgroundColor;
      ds._originalPointBorderColor = ds.pointBorderColor;
      ds._originalPointBackgroundColor = ds.pointBackgroundColor;

      // Force curves and no fill initially
      ds.tension = 0.4;
      ds.lineTension = 0.4; // Legacy fallback
      ds.fill = false;
      ds.pointRadius = 4; // Ensure points are visible

      if (ds._filterName) {
        const checkbox = document.querySelector(`input[name="${ds._filterName}"]`);
        if (checkbox) {
          ds.hidden = !checkbox.checked;
        }
      }
    });

    // State tracking
    let activeDatasetIndex = null;

    // Helper functions for highlighting
    const highlightDataset = (chart, index) => {
      if (activeDatasetIndex === index) return;
      activeDatasetIndex = index;

      chart.data.datasets.forEach((ds, i) => {
        if (i === index) {
          // Active: show fill and gradient
          ds.fill = 'start';
          ds.backgroundColor = createGradient(chart.ctx, chart.chartArea, ds._originalBorderColor);
          ds.borderColor = ds._originalBorderColor;
          ds.pointBorderColor = ds._originalPointBorderColor;
          ds.pointBackgroundColor = ds._originalPointBackgroundColor;
          // Ensure full opacity
          ds.borderWidth = 3;
        } else {
          // Inactive: reduce opacity to 20%
          ds.fill = false;
          ds.borderColor = hexToRgba(ds._originalBorderColor, 0.2);
          // Background color for points/fill
          ds.backgroundColor = hexToRgba(ds._originalBackgroundColor, 0.2);
          ds.pointBorderColor = hexToRgba(ds._originalBorderColor, 0.2);
          ds.pointBackgroundColor = hexToRgba(ds._originalBackgroundColor, 0.2);
          ds.borderWidth = 1;
        }
      });
      chart.update();
    };

    const resetChart = (chart) => {
      if (activeDatasetIndex === null) return;
      activeDatasetIndex = null;

      chart.data.datasets.forEach(ds => {
        ds.fill = false;
        ds.borderColor = ds._originalBorderColor;
        ds.backgroundColor = ds._originalBackgroundColor;
        ds.pointBorderColor = ds._originalPointBorderColor;
        ds.pointBackgroundColor = ds._originalPointBackgroundColor;
        ds.borderWidth = 2; // Default width
      });
      chart.update();
    };

    const chartInstance = new Chart(ctx, {
      type: 'line',
      data: data,
      options: {
        // Use default interaction mode (intersect: true) to avoid sticky hover outside chart
        elements: {
          line: {
            fill: false,
            tension: 0.4,
            lineTension: 0.4 // Legacy
          }
        },
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 250 // Gradual transition 0.25s
        },
        onHover: function(event, elements, chart) {
          const native = event.native;

          if (!chart.chartArea) return;

          const { x, y } = event;
          const { left, right, top, bottom } = chart.chartArea;
          const isInside = x >= left && x <= right && y >= top && y <= bottom;

          if (isInside) {
            // Manually find nearest element in X axis, ignoring intersect
            const nearestElements = chart.getElementsAtEventForMode(event, 'nearest', { intersect: false, axis: 'x' }, true);

            if (nearestElements.length > 0) {
              const index = nearestElements[0].datasetIndex;
              // Reset legend flag since we are active in chart
              chart._isLegendHovered = false;
              highlightDataset(chart, index);

              if (native && native.target) {
                native.target.style.cursor = 'pointer';
              }
            } else {
               // Should rare happen inside chart area
               // But if it does, check legend flag
               if (!chart._isLegendHovered) {
                  resetChart(chart);
                  if (native && native.target) {
                     native.target.style.cursor = 'default';
                  }
               }
            }
          } else {
            // Outside chart area
            // Only reset if we are NOT hovering the legend
            if (!chart._isLegendHovered) {
                resetChart(chart);
                if (native && native.target) {
                  native.target.style.cursor = 'default';
                }
            }
          }
        },
        plugins: {
          legend: {
            position: 'bottom',
            onClick: function(e) {
                // Prevent default click behavior
            },
            onHover: function(event, legendItem, legend) {
              const index = legendItem.datasetIndex;
              legend.chart._isLegendHovered = true;
              highlightDataset(legend.chart, index);

              // Add pointer cursor
              const native = event.native;
              if (native && native.target) {
                native.target.style.cursor = 'pointer';
              }
            },
            onLeave: function(event, legendItem, legend) {
              legend.chart._isLegendHovered = false;
              resetChart(legend.chart);

              const native = event.native;
              if (native && native.target) {
                native.target.style.cursor = 'default';
              }
            },
            labels: {
              filter: function(item, chart) {
                // Only show datasets that are not hidden
                return !item.hidden;
              }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true
          }
        },
        transitions: {
          show: {
            animations: {
              x: {
                from: (ctx) => {
                  if (ctx.chart.scales.x) {
                    return ctx.chart.scales.x.getPixelForValue(labels[0]);
                  }
                  return 0;
                },
                type: 'number',
                easing: 'easeOutQuart',
                duration: 500,
                delay: (ctx) => {
                  if (ctx.type !== 'data') {
                    return 0;
                  }
                  return ctx.dataIndex * 30;
                }
              },
              opacity: {
                from: 0,
                to: 1,
                easing: 'linear',
                duration: 300,
                delay: (ctx) => {
                  if (ctx.type !== 'data') {
                    return 0;
                  }
                  return ctx.dataIndex * 30;
                }
              }
            }
          },
          hide: {
            animations: {
              opacity: {
                to: 0,
                easing: 'linear',
                duration: 300
              }
            }
          }
        }
      }
    });

    // Initial state
    chartInstance._isLegendHovered = false;
  };

  // Initialize on load
  window.initChartEvents();
</script>
