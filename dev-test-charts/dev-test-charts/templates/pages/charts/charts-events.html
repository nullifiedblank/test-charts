<section class="panel-content">

  <!-- Panel ribbon -->
  <ul class="ribbon">

    <li id="ribbon-filters">
      <button
        class="button is-ribbon is-filter"
        hx-get="templates/partials/dropdowns/charts-filters.html"
        hx-trigger="load"
        hx-swap="outerHTML"
      >Filters</button>
    </li>

    <li>
      <p>Data is in UTC timezone</p>
    </li>
  </ul>

  <!-- Chart -->
  <style>
    /* Ensure filters dropdown is above the chart */
    .drop {
      z-index: 2000 !important;
    }
  </style>
  <section class="chart-wrapper">
    <div class="chart is-events">
      <canvas id="chart-events"></canvas>
    </div>
  </section>
</section>
<script>
  window.initChartEvents = function() {
    const ctx = document.getElementById('chart-events');
    if (!ctx) return;

    // Check if chart instance already exists
    const existingChart = Chart.getChart(ctx);
    if (existingChart) {
      existingChart.destroy();
    }

    // Helper to convert hex to rgba
    const hexToRgba = (hex, alpha) => {
        if (!hex || !hex.startsWith('#')) return hex;
        let r = 0, g = 0, b = 0;
        // Handle shorthand #abc
        if (hex.length === 4) {
            r = parseInt(hex[1] + hex[1], 16);
            g = parseInt(hex[2] + hex[2], 16);
            b = parseInt(hex[3] + hex[3], 16);
        } else if (hex.length === 7) {
            r = parseInt(hex.slice(1, 3), 16);
            g = parseInt(hex.slice(3, 5), 16);
            b = parseInt(hex.slice(5, 7), 16);
        }
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const labels = ['January', 'February', 'March', 'April', 'May', 'June', 'July'];

    const data = {
      labels: labels,
      datasets: [
        {
          label: 'Email processed',
          _filterName: 'filter_processed',
          borderColor: '#abb5c4',
          backgroundColor: '#abb5c4',
          data: [65, 59, 80, 81, 56, 55, 40],
        },
        {
          label: 'Soft bounced',
          _filterName: 'filter_soft',
          borderColor: '#e2b466',
          backgroundColor: '#e2b466',
          data: [28, 48, 40, 19, 86, 27, 90],
        },
        {
          label: 'Hard bounced',
          _filterName: 'filter_hard',
          borderColor: '#b3812e',
          backgroundColor: '#b3812e',
          data: [18, 28, 20, 19, 36, 17, 50],
        },
        {
          label: 'Rejected',
          _filterName: 'filter_rejected',
          borderColor: '#a64a39',
          backgroundColor: '#a64a39',
          data: [5, 10, 5, 2, 8, 3, 10],
        },
        {
          label: 'Marked as spam',
          _filterName: 'filter_spam',
          borderColor: '#ce715f',
          backgroundColor: '#ce715f',
          data: [2, 5, 2, 1, 4, 2, 5],
        },
        {
          label: 'Delivered to recipient',
          _filterName: 'filter_delivered',
          borderColor: '#12becb',
          backgroundColor: '#12becb',
          data: [60, 50, 70, 75, 50, 50, 35],
        },
        {
          label: 'Recipient unsubscribed',
          _filterName: 'filter_unsubscribed',
          borderColor: '#01a2ee',
          backgroundColor: '#01a2ee',
          data: [10, 20, 15, 25, 20, 15, 10],
        },
        {
          label: 'Recipient resubscribed',
          _filterName: 'filter_resubscribed',
          borderColor: '#a9c1c1',
          backgroundColor: '#a9c1c1',
          data: [1, 2, 1, 3, 2, 1, 1],
        },
        {
          label: 'Opened by recipient',
          _filterName: 'filter_opened',
          borderColor: '#00ba7a',
          backgroundColor: '#00ba7a',
          data: [50, 40, 60, 65, 40, 40, 25],
        },
        {
          label: 'Link clicked by recipient',
          _filterName: 'filter_clicked',
          borderColor: '#b57ad4',
          backgroundColor: '#b57ad4',
          data: [30, 25, 35, 40, 25, 25, 15],
        }
      ]
    };

    // Apply visibility based on current DOM state of checkboxes
    // Also save original colors
    data.datasets.forEach(ds => {
      ds._originalBorderColor = ds.borderColor;
      ds._originalBackgroundColor = ds.backgroundColor;
      ds._originalPointBorderColor = ds.pointBorderColor;
      ds._originalPointBackgroundColor = ds.pointBackgroundColor;

      if (ds._filterName) {
        const checkbox = document.querySelector(`input[name="${ds._filterName}"]`);
        if (checkbox) {
          ds.hidden = !checkbox.checked;
        }
      }
    });

    let activeLegendIndex = null;

    new Chart(ctx, {
      type: 'line',
      data: data,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 250
        },
        plugins: {
          legend: {
            position: 'bottom',
            onClick: function(e) {},
            onHover: function(event, legendItem, legend) {
              const index = legendItem.datasetIndex;
              if (activeLegendIndex === index) return;
              activeLegendIndex = index;

              const chart = legend.chart;

              chart.data.datasets.forEach((ds, i) => {
                if (i === index) {
                  ds.borderColor = ds._originalBorderColor;
                  ds.backgroundColor = ds._originalBackgroundColor;
                  ds.pointBorderColor = ds._originalPointBorderColor;
                  ds.pointBackgroundColor = ds._originalPointBackgroundColor;
                } else {
                  ds.borderColor = hexToRgba(ds._originalBorderColor, 0.2);
                  ds.backgroundColor = hexToRgba(ds._originalBackgroundColor, 0.2);
                  ds.pointBorderColor = hexToRgba(ds._originalBorderColor, 0.2);
                  ds.pointBackgroundColor = hexToRgba(ds._originalBackgroundColor, 0.2);
                }
              });
              chart.update();

              // Add pointer cursor
              const native = event.native;
              if (native && native.target) {
                native.target.style.cursor = 'pointer';
              }
            },
            onLeave: function(event, legendItem, legend) {
              if (activeLegendIndex === null) return;
              activeLegendIndex = null;

              const chart = legend.chart;

              chart.data.datasets.forEach(ds => {
                ds.borderColor = ds._originalBorderColor;
                ds.backgroundColor = ds._originalBackgroundColor;
                ds.pointBorderColor = ds._originalPointBorderColor;
                ds.pointBackgroundColor = ds._originalPointBackgroundColor;
              });
              chart.update();

              const native = event.native;
              if (native && native.target) {
                native.target.style.cursor = 'default';
              }
            },
            labels: {
              filter: function(item, chart) {
                // Only show datasets that are not hidden
                return !item.hidden;
              }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true
          }
        },
        transitions: {
          show: {
            animations: {
              x: {
                from: (ctx) => {
                  if (ctx.chart.scales.x) {
                    return ctx.chart.scales.x.getPixelForValue(labels[0]);
                  }
                  return 0;
                },
                type: 'number',
                easing: 'easeOutQuart',
                duration: 500,
                delay: (ctx) => {
                  if (ctx.type !== 'data') {
                    return 0;
                  }
                  return ctx.dataIndex * 30;
                }
              },
              opacity: {
                from: 0,
                to: 1,
                easing: 'linear',
                duration: 300,
                delay: (ctx) => {
                  if (ctx.type !== 'data') {
                    return 0;
                  }
                  return ctx.dataIndex * 30;
                }
              }
            }
          },
          hide: {
            animations: {
              opacity: {
                to: 0,
                easing: 'linear',
                duration: 300
              }
            }
          }
        }
      }
    });
  };

  // Initialize on load
  window.initChartEvents();
</script>
